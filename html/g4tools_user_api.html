<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;h1&gt;User API&lt;/h1&gt;</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.20 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><h1>User API</h1>
</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We describe here some of the public methods potentially seen by a user doing analysis.</p>
<h1><a class="anchor" id="g4tools_user_api_booking"></a>
Booking and filling</h1>
<pre class="fragment">    h1d(const std::string&amp; title,unsigned int Xnumber,double Xmin,double Xmax);
    h1d(const std::string&amp; title,const std::vector&lt;double&gt;&amp; edges);

    bool fill(double X,double Weight = 1);
</pre><p> example : </p><pre class="fragment">    #include &lt;tools/histo/h1d&gt;
    #include &lt;tools/randd&gt;
    ...
    tools::histo::h1d h("Gauss",100,-5,5);
    tools::rgaussd rg(1,2);
    for(unsigned int count=0;count&lt;entries;count++) h.fill(rg.shoot(),1.4);
</pre><h1><a class="anchor" id="g4tools_user_api_mean_rms"></a>
Mean and rms</h1>
<pre class="fragment">    tools::histo::h1d h("Gauss",100,-5,5);
    ...
    std::cout &lt;&lt; " mean " &lt;&lt; h.mean() &lt;&lt; ", rms " &lt;&lt; h.rms() &lt;&lt; std::endl;
</pre><h1><a class="anchor" id="g4tools_user_api_bin_infos"></a>
Bin infos</h1>
<p>When doing a : </p><pre class="fragment">    bool fill(double X,double Weight = 1);
</pre><p> the histogram class maintains, for each bin, the number of entries, the sum of weights that we can note "Sw", the sum of W by W "Sw2", the sum of X by Weight "Sxw", the sum of X by X by W "Sx2w". Then bin method names reflect these notations, for example to get the 50 bin sum of X*X*W : </p><pre class="fragment">    double Sx2w = h.bin_Sx2w(50);
</pre><p> and the same for the other sums : </p><pre class="fragment">    double Sw = h.bin_Sw(50);
    double Sw2 = h.bin_Sw2(50);
    double Sxw = h.bin_Sxw(50);
    unsigned int n = h.bin_entries(50);
</pre><p>You can have also all infos on all bins with: </p><pre class="fragment">    tools::histo::h1d h(...);
    ...
    const std::vector&lt;unsigned int&gt;&amp; _entries = h.bins_entries();
    const std::vector&lt;double&gt;&amp; _bins_sum_w = h.bins_sum_w();
    const std::vector&lt;double&gt;&amp; _bins_sum_w2 = h.bins_sum_w2();
    const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_xw = h.bins_sum_xw();
    const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_x2w = h.bins_sum_x2w();
</pre><p> for example to dump bin 50 of an histo booked with 100 bins: </p><pre class="fragment">    std::cout &lt;&lt; "entries[50] = " &lt;&lt; _entries[50] &lt;&lt; std::endl;
    std::cout &lt;&lt; "  sum_w[50] = " &lt;&lt; _bins_sum_w[50] &lt;&lt; std::endl;
    std::cout &lt;&lt; " sum_w2[50] = " &lt;&lt; _bins_sum_w2[50] &lt;&lt; std::endl;
    std::cout &lt;&lt; " sum_xw[50] = " &lt;&lt; _bins_sum_xw[50][0] &lt;&lt; std::endl;   //0 = xaxis
    std::cout &lt;&lt; "sum_x2w[50] = " &lt;&lt; _bins_sum_x2w[50][0] &lt;&lt; std::endl;  //0 = xaxis
</pre><p> (Take care that the [0] entries in the upper vectors are for the "underflow bin" and the last one is for the "overflow bin").</p>
<h1><a class="anchor" id="g4tools_user_api_all_data"></a>
All data</h1>
<p>You can get all internal data of an histo through the histo_data class: </p><pre class="fragment">    const tools::histo::h1d::hd_t&amp; hdata = h.dac();  //dac=data access.
</pre><p> and then, for example, find back the bins infos with: </p><pre class="fragment">    const std::vector&lt;unsigned int&gt;&amp; _entries = hdata.m_bin_entries;
    const std::vector&lt;double&gt;&amp; _bins_sum_w = hdata.m_bin_Sw;
    const std::vector&lt;double&gt;&amp; _bins_sum_w2 = hdata.m_bin_Sw2;
    const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_xw = hdata.m_bin_Sxw;
    const std::vector&lt; std::vector&lt;double&gt; &gt;&amp; _bins_sum_x2w = hdata.m_bin_Sx2w;
    // dump bin 50 :
    std::cout &lt;&lt; "entries[50] = " &lt;&lt; _entries[50] &lt;&lt; std::endl;
    std::cout &lt;&lt; "  sum_w[50] = " &lt;&lt; _bins_sum_w[50] &lt;&lt; std::endl;
    std::cout &lt;&lt; " sum_w2[50] = " &lt;&lt; _bins_sum_w2[50] &lt;&lt; std::endl;
    std::cout &lt;&lt; " sum_xw[50] = " &lt;&lt; _bins_sum_xw[50][0] &lt;&lt; std::endl;   //0 = xaxis
    std::cout &lt;&lt; "sum_x2w[50] = " &lt;&lt; _bins_sum_x2w[50][0] &lt;&lt; std::endl;  //0 = xaxis
</pre><p> See the tools/histo/histo_data class for all internal fields.</p>
<h1><a class="anchor" id="g4tools_user_api_projection"></a>
Projections</h1>
<p>From a 2D histo, you can get the x projection with: </p><pre class="fragment">    tools::histo::h1d* projection = tools::histo::projection_x(h2d,"ProjX");
    ...
    delete projection;
</pre><p> See test/cpp/histo.cpp for example code. Other slicing and projection methods are: </p><pre class="fragment">  // h2d -&gt; h1d. (User gets ownership of the returned object).
  h1d* slice_x(const h2d&amp;,int y_beg_ibin,int y_end_ibin,const std::string&amp; title);
  h1d* projection_x(const h2d&amp;,const std::string&amp; title);
  h1d* slice_y(const h2d&amp;,int x_beg_ibin,int x_end_ibin,const std::string&amp; title);
  h1d* projection_y(const h2d&amp;,const std::string&amp; title);
  // h2d -&gt; p1d. (User gets ownership of the returned object).
  p1d* profile_x(const h2d&amp;,int y_beg_ibin,int y_end_ibin,const std::string&amp; title);
  p1d* profile_x(const h2d&amp;,const std::string&amp;);
  p1d* profile_y(const h2d&amp;,int x_beg_ibin,int x_end_ibin,const std::string&amp; title);
  p1d* profile_y(const h2d&amp;,const std::string&amp; title);
  // h3d -&gt; h2d. (User gets ownership of the returned object).
  h2d* slice_xy(const h3d&amp;,int z_beg_ibin,int z_end_ibin,const std::string&amp; title);
  h2d* projection_xy(const h3d&amp;,const std::string&amp; title);
  h2d* slice_yz(const h3d&amp;,int x_beg_ibin,int x_end_ibin,const std::string&amp; title);
  h2d* projection_yz(const h3d&amp;,const std::string&amp; title);
  h2d* slice_xz(const h3d&amp;,int y_beg_ibin,int y_end_ibin,const std::string&amp; title);
  h2d* projection_xz(const h3d&amp;,const std::string&amp; title);
</pre><h1><a class="anchor" id="g4tools_user_api_bin_tweaking"></a>
Bin tweaking</h1>
<p>Obviously, you should NEVER do that : </p><pre class="fragment">    tools::histo::h1d h(...);
    ...
    unsigned int n;
    double Sw,Sw2,Sxw,Sx2w;
    h.get_bin_content(50,n,Sw,Sw2,Sxw,Sx2w);
    ... // do something naughty on n,Sw,Sw2,Sxw,Sx2w.
    h.set_bin_content(50,n,Sw,Sw2,Sxw,Sx2w); //psss
</pre><p> with a 2D histo : </p><pre class="fragment">    tools::histo::h2d h(...);
    ...
    unsigned int n;
    double Sw,Sw2,Sxw,Sx2w,Syw,Sy2w;
    h.get_bin_content(50,n,Sw,Sw2,Sxw,Sx2w,Syw,Sy2w);
    ... // do something naughty on n,Sw,Sw2,Sxw,Sx2w,Syw,Sy2w.
    h.set_bin_content(50,n,Sw,Sw2,Sxw,Sx2w,Syw,Sy2w); //psss
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->

</body>
</html>
